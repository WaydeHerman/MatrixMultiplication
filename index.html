<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Column Chart Viz</title>
    <style>
      body {
        text-align: center;
      }

      .chart {
        padding-top: 50px;
        margin: auto;
      }
      .viz-container {
        border: 4px solid black;
        display: inline-block;
        height: 620px;
        width: 620px;
        margin: 10px;
      }

      .controls-container {
        height: 100px;
      }

      .slider {
        -webkit-appearance: none;
        display: inline-block;
        width: 24px;
        height: 6px;
        border-radius: 2px;
        background: #d3d3d3;
        margin: 0 auto;
        outline: none;
        opacity: 0.8;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
      }

      /* Mouse-over effects */
      .slider:hover {
        opacity: 1;
        /* Fully shown on mouse-over */
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 8px;
        height: 16px;
        border-radius: 35%;
        background: #54494b;
        cursor: pointer;
      }

      .slider::-moz-range-thumb {
        width: 8px;
        height: 16px;
        border-radius: 35%;
        background: #54494b;
        cursor: pointer;
      }

      .slider {
        stroke: #d3d3d3;
      }

      .track-inset {
        stroke: #d3d3d3;
        stroke-width: 8px;
      }

      .track-overlay {
        pointer-events: stroke;
        stroke-width: 20px;
        stroke: transparent;
        cursor: pointer;
      }

      .handle {
        fill: #54494b;
        stroke: #000;
        stroke-opacity: 0.5;
        stroke-width: 0px;
      }

      .slider-labels {
        text-anchor: middle;
        font-family: "arial";
        font-size: 12px;
        font-weight: bold;
        fill: #54494b;
      }

      .matrix-node {
        stroke: black;
        stroke-width: 2px;
      }

      .memory-node {
        stroke: black;
        stroke-width: 0.5px;
      }

      .play-pause-btn {
        fill: #bab9b9;
        cursor: pointer;
      }

      .play-pause-text {
        fill: white;
        font-weight: bold;
        text-anchor: middle;
        font-family: "arial";
        cursor: pointer;
      }
      .mode-toggle-text-0,
      .mode-toggle-text-1 {
        font-weight: bold;
        font-family: "arial";
        cursor: pointer;
      }

      .line {
        fill: none;
        stroke-width: 3px;
      }

      .tooltip {
        position: fixed;
        z-index: 999;
        left: 0;
        top: 0;
        padding: 0.25em 0.5em;
        border-width: 2px;
        border-style: solid;
        background: rgba(255, 255, 255, 1);
        pointer-events: none;
        display: none;
        font-family: arial;
        text-align: start;
        font-size: 0.8em;
      }

      .tooltip-title {
        font-weight: bold;
      }

      .tick > line {
        display: none;
      }

      .domain {
        display: none;
      }

      .axis-label {
        font-size: 0.8em;
        font-weight: bold;
        text-anchor: middle;
        font-family: arial;
      }

      .legend-label {
        font-family: arial;
        font-size: 0.8em;
        font-weight: bold;
      }
    </style>
    <script src="https://d3js.org/d3.v5.min.js"></script>
  </head>

  <body>
    <div class="tooltip">
      <div class="tooltip-title"></div>
      <div class="naive-info"></div>
      <div class="transpose-info"></div>
      <div class="tiled-info"></div>
    </div>
    <div class="chart">
      <div id="matrix-view" class="viz-container"></div>
      <div id="graph-view" class="viz-container"></div>
      <div class="controls-container"></div>
    </div>

    <script>
      // Global Variables:
      var widthChart = 620;
      var heightChart = 620;
      var sliderMargin = { left: 260, right: 30 };
      var graphMargin = { top: 140, right: 80, bottom: 160, left: 80 };
      var minMatrixN = 1;
      var maxMatrixN = 10;
      var playMode = 0;
      var mode = "naive";
      var xScale, graphData;

      // Sliders;
      var currentN = 1;
      var currentM = 1;
      var currentP = 1;
      var n = currentM * currentM * currentP;

      var chartA = d3
        .select("#matrix-view")
        .append("svg")
        .attr("width", widthChart)
        .attr("height", heightChart)
        .append("g")
        .attr("transform", "translate(0,0)");

      var sliderX = d3
        .scaleLinear()
        .domain([minMatrixN, maxMatrixN])
        .range([sliderMargin.left, widthChart - sliderMargin.right])
        .clamp(true);

      chartA
        .append("rect")
        .attr("x", 10)
        .attr("y", 50)
        .attr("width", 55)
        .attr("height", 30)
        .attr("fill", "#54494b")
        .style("cursor", "pointer")
        .on("click", function() {
          toggleMode();
        });

      var modeToggle = chartA
        .append("rect")
        .attr("x", 15)
        .attr("y", 55)
        .attr("width", 20)
        .attr("height", 20)
        .attr("fill", "white")
        .style("cursor", "pointer")
        .on("click", function() {
          toggleMode();
        });

      chartA
        .append("text")
        .attr("class", "mode-toggle-text-0")
        .text("mode:")
        .attr("fill", "#54494b")
        .attr("x", 75)
        .attr("y", 60);

      chartA
        .append("text")
        .attr("class", "mode-toggle-text-1")
        .text("naive")
        .attr("fill", "#54494b")
        .attr("x", 75)
        .attr("y", 75);

      var sliderNSVG = chartA
        .append("g")
        .attr("transform", "translate(" + 0 + "," + 30 + ")");

      sliderNSVG
        .append("text")
        .attr("class", "slider-labels")
        .attr("dy", "0.3em")
        .text("n: ")
        .attr("x", 230);

      var nLabel = sliderNSVG
        .append("text")
        .attr("class", "slider-labels")
        .attr("dy", "0.3em")
        .text(currentN)
        .attr("x", 245);

      var sliderN = sliderNSVG.append("g").attr("class", "slider");

      sliderN
        .append("line")
        .attr("class", "track")
        .attr("x1", sliderX.range()[0])
        .attr("x2", sliderX.range()[1])
        .select(function() {
          return this.parentNode.appendChild(this.cloneNode(true));
        })
        .attr("class", "track-inset")
        .select(function() {
          return this.parentNode.appendChild(this.cloneNode(true));
        })
        .attr("class", "track-overlay")
        .call(
          d3
            .drag()
            .on("start.interrupt", function() {
              sliderN.interrupt();
            })
            .on("start drag", function() {
              currentN = Math.round(sliderX.invert(d3.event.x));
              handleN.attr("x", function() {
                return sliderX(currentN);
              });
              nLabel.text(currentN);
              console.log("currentN", currentN);
              updateBoxes();
              updateBoxes();
              reset();
            })
        );

      var handleN = sliderN
        .insert("rect", ".track-overlay")
        .attr("class", "handle")
        .attr("y", "-10")
        .attr("x", sliderX(currentN))
        .attr("width", "16px")
        .attr("height", "20px");

      var sliderMSVG = chartA
        .append("g")
        .attr("transform", "translate(" + 0 + "," + 70 + ")");

      sliderMSVG
        .append("text")
        .attr("class", "slider-labels")
        .attr("dy", "0.3em")
        .text("m: ")
        .attr("x", 230);

      var mLabel = sliderMSVG
        .append("text")
        .attr("class", "slider-labels")
        .attr("dy", "0.3em")
        .text(currentM)
        .attr("x", 245);

      var sliderM = sliderMSVG.append("g").attr("class", "slider");

      sliderM
        .append("line")
        .attr("class", "track")
        .attr("x1", sliderX.range()[0])
        .attr("x2", sliderX.range()[1])
        .select(function() {
          return this.parentNode.appendChild(this.cloneNode(true));
        })
        .attr("class", "track-inset")
        .select(function() {
          return this.parentNode.appendChild(this.cloneNode(true));
        })
        .attr("class", "track-overlay")
        .call(
          d3
            .drag()
            .on("start.interrupt", function() {
              sliderM.interrupt();
            })
            .on("start drag", function() {
              currentM = Math.round(sliderX.invert(d3.event.x));
              handleM.attr("x", function() {
                return sliderX(currentM);
              });
              mLabel.text(currentM);
              console.log("currentM", currentM);
              updateBoxes();
              updateBoxes();
              reset();
            })
        );

      var handleM = sliderM
        .insert("rect", ".track-overlay")
        .attr("class", "handle")
        .attr("y", "-10")
        .attr("x", sliderX(currentM))
        .attr("width", "16px")
        .attr("height", "20px");

      var sliderPSVG = chartA
        .append("g")
        .attr("transform", "translate(" + 0 + "," + 110 + ")");

      sliderPSVG
        .append("text")
        .attr("class", "slider-labels")
        .attr("dy", "0.3em")
        .text("p: ")
        .attr("x", 230);

      var pLabel = sliderPSVG
        .append("text")
        .attr("class", "slider-labels")
        .attr("dy", "0.3em")
        .text(currentP)
        .attr("x", 245);

      var sliderP = sliderPSVG.append("g").attr("class", "slider");

      sliderP
        .append("line")
        .attr("class", "track")
        .attr("x1", sliderX.range()[0])
        .attr("x2", sliderX.range()[1])
        .select(function() {
          return this.parentNode.appendChild(this.cloneNode(true));
        })
        .attr("class", "track-inset")
        .select(function() {
          return this.parentNode.appendChild(this.cloneNode(true));
        })
        .attr("class", "track-overlay")
        .call(
          d3
            .drag()
            .on("start.interrupt", function() {
              sliderP.interrupt();
            })
            .on("start drag", function() {
              currentP = Math.round(sliderX.invert(d3.event.x));
              handleP.attr("x", function() {
                return sliderX(currentP);
              });
              pLabel.text(currentP);
              console.log("currentP", currentP);
              updateBoxes();
              updateBoxes();
              reset();
            })
        );

      var handleP = sliderP
        .insert("rect", ".track-overlay")
        .attr("class", "handle")
        .attr("y", "-10")
        .attr("x", sliderX(currentP))
        .attr("width", "16px")
        .attr("height", "20px");

      // setup matrix view boxes:
      var boxWidth = 180;
      var boxHeight = 320;
      var boxASVG = chartA
        .append("g")
        .attr("transform", "translate(" + 10 + "," + 140 + ")");

      /* boxASVG
        .append("rect")
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .attr("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", "2px"); */

      var boxBSVG = chartA
        .append("g")
        .attr("transform", "translate(" + (boxWidth + 40) + "," + 140 + ")");

      /* boxBSVG
        .append("rect")
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .attr("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", "2px"); */

      var boxCSVG = chartA
        .append("g")
        .attr(
          "transform",
          "translate(" + (2 * boxWidth + 70) + "," + 140 + ")"
        );

      chartA
        .append("image")
        .attr("xlink:href", "assets/times-solid.svg")
        .attr("width", 16)
        .attr("height", 16)
        .attr("x", boxWidth + 17)
        .attr("y", 140 + boxHeight / 2);

      chartA
        .append("image")
        .attr("xlink:href", "assets/equals-solid.svg")
        .attr("width", 16)
        .attr("height", 16)
        .attr("x", 2 * boxWidth + 47)
        .attr("y", 140 + boxHeight / 2);

      /* boxCSVG
        .append("rect")
        .attr("width", boxWidth)
        .attr("height", boxHeight)
        .attr("fill", "none")
        .style("stroke", "black")
        .style("stroke-width", "2px"); */

      var dataA = getMatrix(currentM, currentN);
      var dataB = getMatrix(currentP, currentM);
      var dataC = getMatrix(currentP, currentN);

      xScaleM = d3
        .scaleBand()
        .domain([...Array(currentM).keys()])
        .range([0, boxWidth]);

      xScaleP = d3
        .scaleBand()
        .domain([...Array(currentP).keys()])
        .range([0, boxWidth]);

      yScaleN = d3
        .scaleBand()
        .domain([...Array(currentN).keys()])
        .range([0, boxHeight]);

      yScaleM = d3
        .scaleBand()
        .domain([...Array(currentM).keys()])
        .range([0, boxHeight]);

      var boxesA = boxASVG
        .selectAll(".matrix-g")
        .data(dataA)
        .enter()
        .append("g")
        .attr("class", "matrix-g")
        .attr("transform", function(d) {
          return "translate(0," + yScaleN(d.key) + ")";
        })
        .selectAll(".matrix-node")
        .data(function(d) {
          return d.values;
        });

      boxesA
        .enter()
        .append("rect")
        .attr("class", "matrix-node")
        .attr("fill", "#bab9b9")
        .attr("x", function(d) {
          return xScaleM(d.key);
        })
        .attr("height", function(d) {
          return yScaleN.bandwidth();
        })
        .attr("width", function(d) {
          return xScaleM.bandwidth();
        });

      var boxesB = boxBSVG
        .selectAll(".matrix-g")
        .data(dataB)
        .enter()
        .append("g")
        .attr("class", "matrix-g")
        .attr("transform", function(d) {
          return "translate(0," + yScaleM(d.key) + ")";
        })
        .selectAll(".matrix-node")
        .data(function(d) {
          return d.values;
        });

      boxesB
        .enter()
        .append("rect")
        .attr("class", "matrix-node")
        .attr("fill", "#bab9b9")
        .attr("x", function(d) {
          return xScaleP(d.key);
        })
        .attr("height", function(d) {
          return yScaleM.bandwidth();
        })
        .attr("width", function(d) {
          return xScaleP.bandwidth();
        });

      var boxesC = boxCSVG
        .selectAll(".matrix-g")
        .data(dataC)
        .enter()
        .append("g")
        .attr("class", "matrix-g")
        .attr("transform", function(d) {
          return "translate(0," + yScaleN(d.key) + ")";
        })
        .selectAll(".matrix-node")
        .data(function(d) {
          return d.values;
        });

      boxesC
        .enter()
        .append("rect")
        .attr("class", "matrix-node")
        .attr("fill", "#bab9b9")
        .attr("x", function(d) {
          return xScaleP(d.key);
        })
        .attr("height", function(d) {
          return yScaleN.bandwidth();
        })
        .attr("width", function(d) {
          return xScaleP.bandwidth();
        });

      // Memory View:
      var memoryX = 100;
      var memoryY = 1;
      var memoryA = getMatrix(memoryX, memoryY);
      var memoryB = getMatrix(memoryX, memoryY);
      var memoryC = getMatrix(memoryX, memoryY);
      var memoryWidth = widthChart - 20;
      var memoryHeight = 10;

      var xScaleMemory = d3
        .scaleBand()
        .domain([...Array(memoryX).keys()])
        .range([0, memoryWidth]);

      var yScaleMemory = d3
        .scaleBand()
        .domain([...Array(memoryY).keys()])
        .range([0, memoryHeight]);

      var memoryASVG = chartA
        .append("g")
        .attr("transform", "translate(" + 10 + "," + 520 + ")");

      var memoryBSVG = chartA
        .append("g")
        .attr("transform", "translate(" + 10 + "," + 560 + ")");

      var memoryCSVG = chartA
        .append("g")
        .attr("transform", "translate(" + 10 + "," + 600 + ")");

      var memoryAchart = memoryASVG
        .selectAll(".memory-a-g")
        .data(memoryA)
        .enter()
        .append("g")
        .attr("class", "matrix-a-g")
        .attr("transform", function(d) {
          return "translate(0," + yScaleMemory(d.key) + ")";
        })
        .selectAll(".memory-node")
        .data(function(d) {
          return d.values;
        });

      memoryAchart
        .enter()
        .append("rect")
        .attr("class", "memory-node")
        .attr("fill", "#bab9b9")
        .attr("x", function(d) {
          return xScaleMemory(d.key);
        })
        .attr("height", function(d) {
          return yScaleMemory.bandwidth();
        })
        .attr("width", function(d) {
          return xScaleMemory.bandwidth();
        });

      var memoryBchart = memoryBSVG
        .selectAll(".memory-b-g")
        .data(memoryB)
        .enter()
        .append("g")
        .attr("class", "matrix-b-g")
        .attr("transform", function(d) {
          return "translate(0," + yScaleMemory(d.key) + ")";
        })
        .selectAll(".memory-node")
        .data(function(d) {
          return d.values;
        });

      memoryBchart
        .enter()
        .append("rect")
        .attr("class", "memory-node")
        .attr("fill", "#bab9b9")
        .attr("x", function(d) {
          return xScaleMemory(d.key);
        })
        .attr("height", function(d) {
          return yScaleMemory.bandwidth();
        })
        .attr("width", function(d) {
          return xScaleMemory.bandwidth();
        });

      var memoryCchart = memoryCSVG
        .selectAll(".memory-c-g")
        .data(memoryC)
        .enter()
        .append("g")
        .attr("class", "matrix-c-g")
        .attr("transform", function(d) {
          return "translate(0," + yScaleMemory(d.key) + ")";
        })
        .selectAll(".memory-node")
        .data(function(d) {
          return d.values;
        });

      memoryCchart
        .enter()
        .append("rect")
        .attr("class", "memory-node")
        .attr("fill", "#bab9b9")
        .attr("x", function(d) {
          return xScaleMemory(d.key);
        })
        .attr("height", function(d) {
          return yScaleMemory.bandwidth();
        })
        .attr("width", function(d) {
          return xScaleMemory.bandwidth();
        });

      // Graph View:
      d3.csv("times.csv").then(function(data) {
        graphData = data;
        var chartB = d3
          .select("#graph-view")
          .append("svg")
          .attr("width", widthChart)
          .attr("height", heightChart)
          .append("g")
          .attr("transform", "translate(" + 0 + "," + 0 + ")");

        var n = graphData.length;

        console.log(graphData);

        naive = [];
        transpose = [];
        tiled = [];
        n_list = [];
        graphData.forEach(function(v) {
          naive.push(+v["naive"]);
          transpose.push(+v["transpose"]);
          tiled.push(+v["tiled"]);
          n_list.push(+v["N"]);
        });

        var maxVal = d3.max([
          naive.slice(-1),
          transpose.slice(-1),
          tiled.slice(-1)
        ]);

        xScale = d3
          .scaleLinear()
          .domain([0, n - 1]) // input
          .range([graphMargin.left, widthChart - graphMargin.right]); // output

        var yScale = d3
          .scaleLinear()
          .domain([0, maxVal]) // input
          .range([heightChart - graphMargin.bottom, graphMargin.top]); // output

        var line = d3
          .line()
          .x(function(d, i) {
            return xScale(i);
          })
          .y(function(d) {
            console.log("d", d);
            console.log("yScale", yScale(d));
            return yScale(d);
          });

        chartB
          .append("g")
          .attr("class", "x-axis")
          .attr(
            "transform",
            "translate(0," + (heightChart - graphMargin.bottom) + ")"
          )
          .call(
            d3.axisBottom(xScale).tickFormat(function(d, i) {
              return n_list[i];
            })
          );

        chartB
          .append("text")
          .attr("class", "axis-label")
          .attr(
            "transform",
            "translate(" +
              widthChart / 2 +
              " ," +
              (heightChart - graphMargin.bottom + 40) +
              ")"
          )
          .text("N");

        chartB
          .append("g")
          .attr("class", "y-axis")
          .attr("transform", "translate(" + graphMargin.left + ",0)")
          .call(d3.axisLeft(yScale));

        chartB
          .append("text")
          .attr("class", "axis-label")
          .attr("transform", "rotate(-90)")
          .attr("y", graphMargin.left - 50)
          .attr("x", 0 - heightChart / 2)
          .attr("dy", "1em")
          .text("Value");

        chartB
          .append("path")
          .datum(naive)
          .attr("class", "line line-naive")
          .style("stroke", "#235789")
          .attr("d", function(d, i) {
            return line(d, i);
          });

        chartB
          .append("path")
          .datum(transpose)
          .attr("class", "line line-transpose")
          .style("stroke", "#F1D302")
          .attr("d", function(d, i) {
            return line(d, i);
          });

        chartB
          .append("path")
          .datum(tiled)
          .attr("class", "line line-tiled")
          .style("stroke", "#C1292E")
          .attr("d", function(d, i) {
            return line(d, i);
          });

        tipBox = chartB
          .append("rect")
          .attr("x", graphMargin.left)
          .attr("y", graphMargin.top)
          .attr("width", widthChart - graphMargin.right - graphMargin.left)
          .attr("height", heightChart - graphMargin.top - graphMargin.bottom)
          .attr("fill-opacity", 0)
          .on("mousemove", drawTooltip)
          .on("mouseout", hideTooltip)
          .style("stroke", "black")
          .style("stroke-width", 2);

        tooltipLine = chartB.append("line");

        legendText = ["naive", "transpose", "tiled"];

        var legendRectSize = 18;
        var legendSpacing = 18;

        legend = chartB
          .selectAll(".legend")
          .data(legendText)
          .enter()
          .append("g")
          .attr("class", "legend")
          .attr("transform", function(d, i) {
            var height = legendRectSize + legendSpacing;
            var offset = 0;
            var horz = graphMargin.left;
            var vert = heightChart - 110 + i * height + offset;
            return "translate(" + horz + "," + vert + ")";
          })
          .style("cursor", "pointer")
          .on("click", function(d) {
            updateGraph(d);
          });

        legend
          .append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("id", function(d) {
            return "legend-rect-" + d;
          })
          .attr("width", legendRectSize)
          .attr("height", legendRectSize)
          .style("stroke", "black")
          .style("stroke-width", 2)
          .attr("fill", function(d, i) {
            if (i === 0) {
              return "#235789";
            }
            if (i === 1) {
              return "#F1D302";
            }
            if (i === 2) {
              return "#C1292E";
            }
          });

        legend
          .append("text")
          .attr("class", "legend-label")
          .attr("x", 25)
          .attr("y", 13)
          .attr("id", function(d) {
            return "legend-label-" + d;
          })
          .text(function(d) {
            return d;
          });
      });

      // Controls:
      var controlSVG = d3
        .select(".controls-container")
        .append("svg")
        .attr("width", 200)
        .attr("height", 100)
        .append("g")
        .attr("transform", "translate(0,0)")
        .on("mouseover", function() {
          d3.select(".play-pause-btn").style("fill", "black");
        })
        .on("mouseout", function() {
          d3.select(".play-pause-btn").style("fill", "#bab9b9");
        });

      controlSVG
        .append("rect")
        .attr("class", "play-pause-btn")
        .attr("y", 20)
        .attr("x", 50)
        .attr("width", 100)
        .attr("height", 50)
        .on("click", function() {
          console.log("n", n);
          if (playMode === 0) {
            playMode = 1;
            currentStep = 0;
            d3.select(".play-pause-text").text("Pause");
            timer = setInterval(function() {
              if (currentStep < n) {
                console.log(currentStep);
                step();
                currentStep += 1;
              } else {
                clearInterval(timer);
                playMode = 0;
                d3.select(".play-pause-text").text("Play");
              }
            }, 1000);
          } else {
            clearInterval(timer);
            playMode = 0;
            d3.select(".play-pause-text").text("Play");
          }
        });

      controlSVG
        .append("text")
        .attr("class", "play-pause-text")
        .text("play")
        .attr("y", 50)
        .attr("x", 100);

      function updateGraph(d) {
        console.log(d3.select("#legend-rect-" + d).attr("opacity"));
        if (d3.select("#legend-rect-" + d).attr("opacity") == 0.5) {
          d3.select("#legend-rect-" + d).attr("opacity", 1);
          d3.select("#legend-label-" + d).attr("opacity", 1);
          d3.select(".line-" + d).attr("opacity", 1);
          d3.select("." + d + "-info").style("display", "");
        } else {
          d3.select("#legend-rect-" + d).attr("opacity", 0.5);
          d3.select("#legend-label-" + d).attr("opacity", 0.5);
          d3.select(".line-" + d).attr("opacity", 0);
          d3.select("." + d + "-info").style("display", "none");
        }
      }

      function hideTooltip() {
        d3.select(".tooltip").style("display", "none");
        tooltipLine.style("display", "none");
      }

      function drawTooltip() {
        let x = d3.event.clientX;
        let y = d3.event.clientY;
        let xInvert = Math.floor(xScale.invert(x) - 12);

        d3.select(".tooltip").style(
          "transform",
          `translate(${x + 10}px,${y + 10}px)`
        );

        tooltipLine
          .style("stroke", "grey")
          .style("display", "")
          .style("stroke-width", 2)
          .style("stroke-dasharray", "3, 3")
          .attr("x1", xScale(xInvert))
          .attr("x2", xScale(xInvert))
          .attr("y1", graphMargin.top)
          .attr("y2", heightChart - graphMargin.bottom);

        d3.select(".tooltip").style("display", "block");
        d3.select(".tooltip-title").text("N: " + n_list[xInvert]);
        d3.select(".naive-info").text(
          "Naive: " + graphData[xInvert]["naive"] + " seconds"
        );
        d3.select(".transpose-info").text(
          "Transpose: " + graphData[xInvert]["transpose"] + " seconds"
        );
        d3.select(".tiled-info").text(
          "Tiled: " + graphData[xInvert]["tiled"] + " seconds"
        );
      }

      function toggleMode() {
        if (mode === "naive") {
          mode = "transpose";
          modeToggle.attr("x", 40);
          updateBoxes();
          updateBoxes();
          reset();
          d3.select(".mode-toggle-text-1").text("transpose");
        } else {
          mode = "naive";
          modeToggle.attr("x", 15);
          updateBoxes();
          updateBoxes();
          reset();
          d3.select(".mode-toggle-text-1").text("naive");
        }
      }

      function reset() {
        boxASVG.selectAll(".matrix-node").attr("fill", "#bab9b9");
        boxBSVG.selectAll(".matrix-node").attr("fill", "#bab9b9");
        boxCSVG.selectAll(".matrix-node").attr("fill", "#bab9b9");
        memoryASVG.selectAll(".memory-node").attr("fill", "#bab9b9");
        memoryBSVG.selectAll(".memory-node").attr("fill", "#bab9b9");
        memoryCSVG.selectAll(".memory-node").attr("fill", "#bab9b9");
      }

      function step() {
        // x is row
        // y is column
        // z is block element

        console.log("currentP", currentP);
        console.log("currentN", currentN);
        console.log("currentM", currentM);
        var index = 0;
        loop0: for (let i = 0; i < currentN; i++) {
          loop1: for (let j = 0; j < currentP; j++) {
            loop2: for (let k = 0; k < currentM; k++) {
              if (index === currentStep) {
                var x = i;
                var y = j;
                var z = k;
                break loop0;
              }
              index++;
            }
          }
        }
        console.log("x", x);
        console.log("y", y);
        console.log("z", z);

        if (mode === "naive") {
          y_next = currentStep;
          if (y_next + 1 > currentP) {
            y_next = currentP - 1;
          }

          highlightMatrix("", x, dataA);
          highlightMatrix(y, "", dataB);
          highlightMatrix(y, x, dataC);
          activateMatrix("", x, z, dataA);
          activateMatrix(y, "", z, dataB);
          activateMatrix(y, x, 0, dataC);
          highlightMemory(x, "", memoryA, "row");
          highlightMemory("", y, memoryB, "column");
          highlightMemory(x, "", memoryC, "point");
          activateMemory(x, "", z, memoryA, "row");
          activateMemory("", y, z, memoryB, "column");
          activateMemory(x, "", z, memoryC, "point");
        } else {
          // think wrong:
          y_next = currentStep;
          if (y_next + 1 > currentP) {
            y_next = currentP - 1;
          }
          highlightMatrix("", x, dataA);
          highlightMatrix("", y, dataB);
          highlightMatrix(y, x, dataC);
          activateMatrix("", x, z, dataA);
          activateMatrix("", y, z, dataB);
          activateMatrix(y, x, 0, dataC);
          highlightMemory(x, "", memoryA, "row");
          highlightMemory(y, "", memoryB, "row");
          highlightMemory(x, "", memoryC, "point");
          activateMemory(x, "", z, memoryA, "row");
          activateMemory(y, "", z, memoryB, "row");
          activateMemory(x, "", z, memoryC, "point");
        }

        update_charts();
      }

      function update_charts() {
        boxASVG
          .selectAll(".matrix-node")
          .attr("fill", function(d) {
            if (d.highlight === true) {
              return "#235789";
            } else {
              return "#bab9b9";
            }
          })
          .style("stroke-width", function(d) {
            if (d.active === true) {
              d3.select(this).moveToFront();
              d3.select(this.parentNode).moveToFront();
              return 6;
            } else {
              return 2;
            }
          });
        boxBSVG
          .selectAll(".matrix-node")
          .attr("fill", function(d) {
            if (d.highlight === true) {
              return "#F1D302";
            } else {
              return "#bab9b9";
            }
          })
          .style("stroke-width", function(d) {
            if (d.active === true) {
              d3.select(this).moveToFront();
              d3.select(this.parentNode).moveToFront();
              return 6;
            } else {
              return 2;
            }
          });
        boxCSVG
          .selectAll(".matrix-node")
          .attr("fill", function(d) {
            if (d.highlight === true) {
              return "#C1292E";
            } else {
              return "#bab9b9";
            }
          })
          .style("stroke-width", function(d) {
            if (d.active === true) {
              d3.select(this).moveToFront();
              d3.select(this.parentNode).moveToFront();
              return 6;
            } else {
              return 2;
            }
          });
        memoryASVG
          .selectAll(".memory-node")
          .attr("fill", function(d) {
            if (d.highlight === true) {
              return "#235789";
            } else {
              return "#bab9b9";
            }
          })
          .style("stroke-width", function(d) {
            if (d.active === true) {
              d3.select(this).moveToFront();
              d3.select(this.parentNode).moveToFront();
              return 2;
            } else {
              return 0.5;
            }
          });
        memoryBSVG
          .selectAll(".memory-node")
          .attr("fill", function(d) {
            if (d.highlight === true) {
              return "#F1D302";
            } else {
              return "#bab9b9";
            }
          })
          .style("stroke-width", function(d) {
            if (d.active === true) {
              d3.select(this).moveToFront();
              d3.select(this.parentNode).moveToFront();
              return 2;
            } else {
              return 0.5;
            }
          });
        memoryCSVG
          .selectAll(".memory-node")
          .attr("fill", function(d) {
            if (d.highlight === true) {
              return "#C1292E";
            } else {
              return "#bab9b9";
            }
          })
          .style("stroke-width", function(d) {
            if (d.active === true) {
              d3.select(this).moveToFront();
              d3.select(this.parentNode).moveToFront();
              return 2;
            } else {
              return 0.5;
            }
          });
      }

      function updateBoxes() {
        n = currentN * currentP * currentM;

        dataA = getMatrix(currentM, currentN);
        if (mode === "naive") {
          dataB = getMatrix(currentP, currentM);
        } else {
          dataB = getMatrix(currentM, currentP);
        }
        dataC = getMatrix(currentP, currentN);

        xScaleM = d3
          .scaleBand()
          .domain([...Array(currentM).keys()])
          .range([0, boxWidth]);

        xScaleP = d3
          .scaleBand()
          .domain([...Array(currentP).keys()])
          .range([0, boxWidth]);

        yScaleN = d3
          .scaleBand()
          .domain([...Array(currentN).keys()])
          .range([0, boxHeight]);

        yScaleM = d3
          .scaleBand()
          .domain([...Array(currentM).keys()])
          .range([0, boxHeight]);

        yScaleP = d3
          .scaleBand()
          .domain([...Array(currentP).keys()])
          .range([0, boxHeight]);

        var gAUpdate = boxASVG.selectAll(".matrix-g").data(dataA);
        //
        var gBUpdate = boxBSVG.selectAll(".matrix-g").data(dataB);
        var gCUpdate = boxCSVG.selectAll(".matrix-g").data(dataC);

        gAUpdate.exit().remove();
        //
        gBUpdate.exit().remove();
        gCUpdate.exit().remove();

        gAUpdate
          .enter()
          .append("g")
          .attr("class", "matrix-g");
        //
        gBUpdate
          .enter()
          .append("g")
          .attr("class", "matrix-g");
        gCUpdate
          .enter()
          .append("g")
          .attr("class", "matrix-g");

        var boxAUpdate = gAUpdate.selectAll(".matrix-node").data(function(d) {
          return d.values;
        });
        //
        var boxBUpdate = gBUpdate.selectAll(".matrix-node").data(function(d) {
          return d.values;
        });
        var boxCUpdate = gCUpdate.selectAll(".matrix-node").data(function(d) {
          return d.values;
        });

        boxAUpdate.exit().remove();
        //
        boxBUpdate.exit().remove();
        boxCUpdate.exit().remove();

        boxAUpdate
          .enter()
          .append("rect")
          .attr("class", "matrix-node");
        //
        boxBUpdate
          .enter()
          .append("rect")
          .attr("class", "matrix-node");
        boxCUpdate
          .enter()
          .append("rect")
          .attr("class", "matrix-node");

        boxASVG.selectAll(".matrix-g").attr("transform", function(d) {
          return "translate(0," + yScaleN(d.key) + ")";
        });
        //
        if (mode === "naive") {
          boxBSVG.selectAll(".matrix-g").attr("transform", function(d) {
            return "translate(0," + yScaleM(d.key) + ")";
          });
        } else {
          boxBSVG.selectAll(".matrix-g").attr("transform", function(d) {
            return "translate(0," + yScaleP(d.key) + ")";
          });
        }

        boxCSVG.selectAll(".matrix-g").attr("transform", function(d) {
          return "translate(0," + yScaleN(d.key) + ")";
        });

        boxASVG
          .selectAll(".matrix-node")
          .attr("x", function(d) {
            return xScaleM(d.key);
          })
          .attr("height", function(d) {
            return yScaleN.bandwidth();
          })
          .attr("width", function(d) {
            return xScaleM.bandwidth();
          });
        //
        if (mode === "naive") {
          boxBSVG
            .selectAll(".matrix-node")
            .attr("x", function(d) {
              return xScaleP(d.key);
            })
            .attr("height", function(d) {
              return yScaleM.bandwidth();
            })
            .attr("width", function(d) {
              return xScaleP.bandwidth();
            });
        } else {
          boxBSVG
            .selectAll(".matrix-node")
            .attr("x", function(d) {
              return xScaleM(d.key);
            })
            .attr("height", function(d) {
              return yScaleP.bandwidth();
            })
            .attr("width", function(d) {
              return xScaleM.bandwidth();
            });
        }

        boxCSVG
          .selectAll(".matrix-node")
          .attr("x", function(d) {
            return xScaleP(d.key);
          })
          .attr("height", function(d) {
            return yScaleN.bandwidth();
          })
          .attr("width", function(d) {
            return xScaleP.bandwidth();
          });
      }

      function activateMatrix(x, y, z, matrix) {
        /*
        Takes a matrix and activates nodes.
        x is column, y is row, z is the index of the block in question
        */
        index = 0;
        matrix.forEach(function(v, i) {
          v.values.forEach(function(w, j) {
            w.active = false;
            if (
              (j === x && i === y) ||
              (j === x && y === "") ||
              (i === y && x === "")
            ) {
              if (index === z) {
                w.active = true;
              }
              index++;
            }
          });
        });
      }

      function activateMemory(x, y, z, memory, type) {
        if (type === "row") {
          index = 0;
          memory.forEach(function(v, i) {
            v.values.forEach(function(w, j) {
              w.active = false;
              if (j < (x + 1) * currentM && j >= x * currentM) {
                if (index === z) {
                  w.active = true;
                }
                index++;
              }
            });
          });
        }
        if (type === "point") {
          memory.forEach(function(v, i) {
            v.values.forEach(function(w, j) {
              w.active = false;
              if (j === Math.floor(currentStep / currentM)) {
                w.active = true;
              }
            });
          });
        }
        if (type === "column") {
          indices = [];
          for (let i = 0; i < currentM; i++) {
            indices.push(i * currentP + y);
          }
          index = 0;
          memory.forEach(function(v, i) {
            v.values.forEach(function(w, j) {
              w.active = false;
              if (indices.indexOf(j) >= 0) {
                if (index === z) {
                  w.active = true;
                }
                index++;
              }
            });
          });
        }
      }

      function highlightMemory(x, y, memory, type) {
        if (type === "row") {
          memory.forEach(function(v, i) {
            v.values.forEach(function(w, j) {
              w.highlight = false;
              if (j < (x + 1) * currentM && j >= x * currentM) {
                w.highlight = true;
              }
            });
          });
        }
        if (type === "point") {
          memory.forEach(function(v, i) {
            v.values.forEach(function(w, j) {
              if (j === Math.floor(currentStep / currentM)) {
                w.highlight = true;
              }
            });
          });
        }
        if (type === "column") {
          indices = [];
          for (let i = 0; i < currentM; i++) {
            indices.push(i * currentP + y);
          }
          console.log(indices);
          memory.forEach(function(v, i) {
            v.values.forEach(function(w, j) {
              w.highlight = false;
              if (indices.indexOf(j) >= 0) {
                w.highlight = true;
              }
            });
          });
        }
      }

      function highlightMatrix(x, y, matrix, next = 0) {
        /*
        Takes a matrix and highlights nodes.
        Can be a x, y pair or a row or a column
        */
        if (next === 0) {
          matrix.forEach(function(v, i) {
            v.values.forEach(function(w, j) {
              w.highlight = false;

              if (
                (j === x && i === y) ||
                (j === x && y === "") ||
                (i === y && x === "")
              ) {
                w.highlight = true;
              }
            });
          });
        } else {
          var added = 0;
          matrix.forEach(function(v, i) {
            v.values.forEach(function(w, j) {
              if (added < next) {
                w.highlight = true;
                added += 1;
              } else {
                w.highlight = false;
              }
            });
          });
        }

        return matrix;
      }

      function getMatrix(m, n) {
        // create a nested array based on given dimensions, m x n.
        result = [];
        var mArray = [...Array(n).keys()];
        var nArray = [...Array(m).keys()];
        mArray.forEach(function(v) {
          var obj = { key: v, values: [] };
          nArray.forEach(function(w) {
            obj.values.push({ key: w, highlight: false, active: false });
          });
          result.push(obj);
        });
        return result;
      }

      d3.selection.prototype.moveToFront = function() {
        return this.each(function() {
          this.parentNode.appendChild(this);
        });
      };
    </script>
  </body>
</html>
